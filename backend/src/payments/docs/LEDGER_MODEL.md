# Ledger Model - Detailed Specification

## Overview

The **LedgerEntry** model is the foundation of the Payments Module, implementing an **immutable, append-only transaction log** with strict invariant enforcement. Every financial movement in the system is recorded as one or more ledger entries.

---

## Model Definition

```prisma
model LedgerEntry {
  id          String   @id @default(uuid())

  // Wallet association
  walletId    String
  wallet      Wallet   @relation(fields: [walletId], references: [id])

  // Transaction details
  amount      Decimal  @db.Decimal(15, 2) // Positive = credit, Negative = debit

  // Entry metadata
  entryType   LedgerEntryType
  description String

  // Transaction grouping
  // CRITICAL: All entries with same transactionId MUST sum to 0
  transactionId String

  // Related entities (polymorphic references)
  paymentId   String?
  payment     Payment? @relation(fields: [paymentId], references: [id])

  orderId     String?
  order       Order?   @relation(fields: [orderId], references: [id])

  refundId    String?
  refund      Refund?  @relation(fields: [refundId], references: [id])

  // Idempotency
  idempotencyKey String? @unique

  // Audit (immutable - no updatedAt)
  createdAt   DateTime @default(now())
  createdBy   String? // User ID who triggered this entry

  @@index([walletId])
  @@index([transactionId])
  @@index([paymentId])
  @@index([orderId])
  @@index([createdAt])
  @@map("ledger_entries")
}
```

---

## Field Specifications

### `id` - Primary Key

- **Type**: UUID
- **Purpose**: Unique identifier for this ledger entry
- **Generation**: Auto-generated by Prisma
- **Immutable**: Never changes after creation

### `walletId` - Wallet Reference

- **Type**: String (UUID)
- **Purpose**: Links entry to specific wallet
- **Required**: Yes
- **Indexed**: Yes (for fast balance queries)
- **Foreign Key**: References `Wallet.id`

### `amount` - Transaction Amount

- **Type**: Decimal(15, 2)
- **Purpose**: The monetary value of this entry
- **Sign Convention**:
  - **Positive** (+): Credit (money IN to wallet)
  - **Negative** (−): Debit (money OUT of wallet)
- **Precision**: 15 digits total, 2 decimal places (₹9,999,999,999,999.99 max)
- **Validation**: Must not be zero

**Examples**:

```typescript
// Buyer pays ₹1000
{
  amount: -1000.0;
} // Debit from buyer wallet

// Seller receives ₹975
{
  amount: +975.0;
} // Credit to seller wallet

// Platform receives ₹25 fee
{
  amount: +25.0;
} // Credit to platform wallet
```

### `entryType` - Entry Classification

- **Type**: Enum `LedgerEntryType`
- **Purpose**: Categorizes the type of financial movement
- **Required**: Yes
- **Indexed**: No (use for filtering in reports)

**Enum Values**:

```prisma
enum LedgerEntryType {
  PAYMENT_DEBIT        // Buyer pays for order
  PAYMENT_CREDIT       // Seller receives payment
  PLATFORM_FEE_DEBIT   // Seller's platform fee deduction
  PLATFORM_FEE_CREDIT  // Platform receives fee
  REFUND_DEBIT         // Seller/Platform pays refund
  REFUND_CREDIT        // Buyer receives refund
  ADJUSTMENT_DEBIT     // Manual correction (decrease)
  ADJUSTMENT_CREDIT    // Manual correction (increase)
  REFERRAL_CREDIT      // Referrer receives reward
  REFERRAL_DEBIT       // Buyer uses referral discount
}
```

### `description` - Human-Readable Text

- **Type**: String
- **Purpose**: Explains what this entry represents
- **Required**: Yes
- **Max Length**: 500 characters (recommended)
- **Example**: `"Payment for order ORD-2026-0001"`

### `transactionId` - Transaction Grouping

- **Type**: String (UUID recommended)
- **Purpose**: Links related ledger entries together
- **Required**: Yes
- **Indexed**: Yes (for invariant checks)
- **Invariant**: All entries with same `transactionId` MUST sum to 0

**Example**:

```typescript
// Payment of ₹1000 with ₹25 platform fee
const transactionId = 'txn_20260101_abc123';

// Entry 1: Buyer pays
{ transactionId, walletId: buyerWallet, amount: -1000 }

// Entry 2: Seller receives
{ transactionId, walletId: sellerWallet, amount: +975 }

// Entry 3: Platform receives fee
{ transactionId, walletId: platformWallet, amount: +25 }

// Sum: -1000 + 975 + 25 = 0 ✅
```

### `paymentId` - Payment Reference (Optional)

- **Type**: String (UUID) or null
- **Purpose**: Links entry to a Payment record
- **Indexed**: Yes
- **Use Case**: Payment capture, payment failure

### `orderId` - Order Reference (Optional)

- **Type**: String (UUID) or null
- **Purpose**: Links entry to an Order
- **Indexed**: Yes
- **Use Case**: Order-related financial movements

### `refundId` - Refund Reference (Optional)

- **Type**: String (UUID) or null
- **Purpose**: Links entry to a Refund record
- **Indexed**: Yes
- **Use Case**: Refund processing

### `idempotencyKey` - Duplicate Prevention

- **Type**: String or null
- **Purpose**: Prevents duplicate ledger entries
- **Unique**: Yes (database constraint)
- **Format**: `{operation}-{entityId}-{timestamp}` (recommended)
- **Example**: `payment-capture-pay123-1704096000`

**Usage**:

```typescript
// If entry with this key exists, skip creation
const existingEntry = await prisma.ledgerEntry.findUnique({
  where: { idempotencyKey: 'payment-capture-pay123-1704096000' },
});

if (existingEntry) {
  return existingEntry; // Idempotent - return existing
}

// Otherwise, create new entry with this key
```

### `createdAt` - Creation Timestamp

- **Type**: DateTime
- **Purpose**: When this entry was created
- **Auto-generated**: Yes
- **Indexed**: Yes (for time-based queries)
- **Immutable**: Never changes
- **Note**: NO `updatedAt` field (entries are immutable)

### `createdBy` - Audit Trail

- **Type**: String (User ID) or null
- **Purpose**: Tracks who triggered this entry
- **Optional**: Yes (system-initiated entries may be null)
- **Use Case**: Admin adjustments, manual corrections

---

## Ledger Invariant (Critical)

### The Golden Rule

**For every `transactionId`, the sum of all `amount` values MUST equal 0.**

```sql
-- This query should ALWAYS return EMPTY results
SELECT transactionId, SUM(amount) as total
FROM ledger_entries
GROUP BY transactionId
HAVING SUM(amount) != 0;
```

### Why This Matters

1. **Double-Entry Bookkeeping**: Every debit has an equal credit
2. **Financial Accuracy**: Money doesn't appear or disappear
3. **Audit Trail**: Transactions are balanced and verifiable
4. **Fraud Prevention**: Unbalanced transactions are immediately detected

### Enforcement

**LedgerService** validates the invariant after EVERY transaction:

```typescript
async verifyTransactionBalance(transactionId: string): Promise<void> {
  const entries = await this.prisma.ledgerEntry.findMany({
    where: { transactionId },
  });

  const sum = entries.reduce((acc, entry) =>
    acc.add(entry.amount), new Decimal(0)
  );

  if (!sum.equals(0)) {
    // CRITICAL ERROR - This should never happen
    await this.alertAdmin(`Ledger invariant violated: ${transactionId}`);
    throw new Error(`Ledger invariant violated: sum = ${sum}`);
  }
}
```

---

## Entry Type Patterns

### 1. Simple Payment (2 Entries)

**Scenario**: Buyer pays ₹500, no platform fee

```typescript
const transactionId = uuid();

// Entry 1: Buyer pays
{
  walletId: buyerWallet.id,
  amount: new Decimal(-500),
  entryType: 'PAYMENT_DEBIT',
  description: 'Payment for order ORD-2026-0001',
  transactionId,
  paymentId: payment.id,
  orderId: order.id,
}

// Entry 2: Seller receives
{
  walletId: sellerWallet.id,
  amount: new Decimal(500),
  entryType: 'PAYMENT_CREDIT',
  description: 'Payment for order ORD-2026-0001',
  transactionId,
  paymentId: payment.id,
  orderId: order.id,
}

// Verification: -500 + 500 = 0 ✅
```

### 2. Payment with Platform Fee (3 Entries)

**Scenario**: Buyer pays ₹1000, platform fee 2.5% (₹25)

```typescript
const transactionId = uuid();

// Entry 1: Buyer pays
{
  walletId: buyerWallet.id,
  amount: new Decimal(-1000),
  entryType: 'PAYMENT_DEBIT',
  description: 'Payment for order ORD-2026-0002',
  transactionId,
  paymentId: payment.id,
  orderId: order.id,
}

// Entry 2: Seller receives (after fee)
{
  walletId: sellerWallet.id,
  amount: new Decimal(975), // 1000 - 25
  entryType: 'PAYMENT_CREDIT',
  description: 'Payment for order ORD-2026-0002',
  transactionId,
  paymentId: payment.id,
  orderId: order.id,
}

// Entry 3: Platform receives fee
{
  walletId: platformWallet.id,
  amount: new Decimal(25),
  entryType: 'PLATFORM_FEE_CREDIT',
  description: 'Platform fee for order ORD-2026-0002',
  transactionId,
  paymentId: payment.id,
  orderId: order.id,
}

// Verification: -1000 + 975 + 25 = 0 ✅
```

### 3. Full Refund without Platform Fee (2 Entries)

**Scenario**: Refund ₹1000 to buyer, keep platform fee

```typescript
const transactionId = uuid();

// Entry 1: Seller pays refund
{
  walletId: sellerWallet.id,
  amount: new Decimal(-1000),
  entryType: 'REFUND_DEBIT',
  description: 'Refund for order ORD-2026-0002',
  transactionId,
  refundId: refund.id,
  orderId: order.id,
}

// Entry 2: Buyer receives refund
{
  walletId: buyerWallet.id,
  amount: new Decimal(1000),
  entryType: 'REFUND_CREDIT',
  description: 'Refund for order ORD-2026-0002',
  transactionId,
  refundId: refund.id,
  orderId: order.id,
}

// Note: Platform keeps the ₹25 fee (no entry for platform)
// Verification: -1000 + 1000 = 0 ✅
```

### 4. Full Refund with Platform Fee Refund (4 Entries)

**Scenario**: Refund ₹1000 to buyer, also refund ₹25 platform fee

```typescript
const transactionId = uuid();

// Entry 1: Seller pays refund
{
  walletId: sellerWallet.id,
  amount: new Decimal(-975), // What they received
  entryType: 'REFUND_DEBIT',
  description: 'Refund for order ORD-2026-0002',
  transactionId,
  refundId: refund.id,
  orderId: order.id,
}

// Entry 2: Platform pays back fee
{
  walletId: platformWallet.id,
  amount: new Decimal(-25),
  entryType: 'PLATFORM_FEE_DEBIT',
  description: 'Platform fee refund for order ORD-2026-0002',
  transactionId,
  refundId: refund.id,
  orderId: order.id,
}

// Entry 3: Buyer receives full refund
{
  walletId: buyerWallet.id,
  amount: new Decimal(1000),
  entryType: 'REFUND_CREDIT',
  description: 'Refund for order ORD-2026-0002',
  transactionId,
  refundId: refund.id,
  orderId: order.id,
}

// Verification: -975 + (-25) + 1000 = 0 ✅
```

### 5. Referral Discount Application (2 Entries)

**Scenario**: Buyer uses ₹50 referral discount on order

```typescript
const transactionId = uuid();

// Entry 1: Debit referral reward from referrer
{
  walletId: referrerWallet.id,
  amount: new Decimal(-50),
  entryType: 'REFERRAL_DEBIT',
  description: 'Referral discount applied to order ORD-2026-0003',
  transactionId,
  orderId: order.id,
}

// Entry 2: Credit discount to buyer
{
  walletId: buyerWallet.id,
  amount: new Decimal(50),
  entryType: 'REFERRAL_CREDIT',
  description: 'Referral discount for order ORD-2026-0003',
  transactionId,
  orderId: order.id,
}

// Verification: -50 + 50 = 0 ✅
```

### 6. Manual Admin Adjustment (2 Entries)

**Scenario**: Admin corrects ₹100 error in buyer wallet

```typescript
const transactionId = uuid();

// Entry 1: Credit buyer (correction)
{
  walletId: buyerWallet.id,
  amount: new Decimal(100),
  entryType: 'ADJUSTMENT_CREDIT',
  description: 'Admin adjustment: Compensation for delivery issue',
  transactionId,
  createdBy: adminUserId,
}

// Entry 2: Debit platform (absorb cost)
{
  walletId: platformWallet.id,
  amount: new Decimal(-100),
  entryType: 'ADJUSTMENT_DEBIT',
  description: 'Admin adjustment: Delivery issue compensation',
  transactionId,
  createdBy: adminUserId,
}

// Verification: 100 + (-100) = 0 ✅
```

---

## Balance Calculation

Wallet balance is **ALWAYS** computed from ledger entries:

```typescript
// WalletService method
async getWalletBalance(walletId: string): Promise<Decimal> {
  const result = await this.prisma.ledgerEntry.aggregate({
    where: { walletId },
    _sum: { amount: true },
  });

  return result._sum.amount || new Decimal(0);
}
```

**Why this works**:

- Every credit adds to balance
- Every debit subtracts from balance
- Initial balance is 0 (no entries = 0 balance)
- Balance is always accurate (derived from immutable data)

---

## Query Patterns

### Get Wallet Transaction History

```typescript
const transactions = await prisma.ledgerEntry.findMany({
  where: { walletId: wallet.id },
  orderBy: { createdAt: 'desc' },
  take: 50, // Paginate
  include: {
    payment: true,
    order: { select: { orderNumber: true } },
    refund: true,
  },
});
```

### Get Transactions for Specific Order

```typescript
const orderTransactions = await prisma.ledgerEntry.findMany({
  where: { orderId: order.id },
  orderBy: { createdAt: 'asc' },
  include: {
    wallet: { select: { walletType: true, userId: true } },
  },
});
```

### Get Transactions by Date Range

```typescript
const dateRangeTransactions = await prisma.ledgerEntry.findMany({
  where: {
    walletId: wallet.id,
    createdAt: {
      gte: startDate,
      lte: endDate,
    },
  },
  orderBy: { createdAt: 'desc' },
});
```

### Verify Ledger Integrity (All Transactions)

```typescript
const unbalancedTransactions = await prisma.$queryRaw`
  SELECT transaction_id, SUM(amount) as total
  FROM ledger_entries
  GROUP BY transaction_id
  HAVING SUM(amount) != 0
`;

if (unbalancedTransactions.length > 0) {
  throw new Error('Ledger integrity violation detected');
}
```

---

## Edge Cases & Validation

### 1. Zero Amount Entry

**Rule**: Ledger entries with amount = 0 are **NOT allowed**.

**Validation**:

```typescript
if (amount.equals(0)) {
  throw new BadRequestException('Ledger entry amount cannot be zero');
}
```

### 2. Orphaned Transaction

**Rule**: All entries must reference at least one entity (payment, order, or refund).

**Validation**:

```typescript
if (!paymentId && !orderId && !refundId && !isAdminAdjustment) {
  throw new BadRequestException('Ledger entry must reference an entity');
}
```

### 3. Duplicate Idempotency Key

**Rule**: Attempting to create entry with existing `idempotencyKey` returns existing entry.

**Implementation**:

```typescript
try {
  return await prisma.ledgerEntry.create({ data });
} catch (error) {
  if (error.code === 'P2002') {
    // Unique constraint violation
    return await prisma.ledgerEntry.findUnique({
      where: { idempotencyKey: data.idempotencyKey },
    });
  }
  throw error;
}
```

### 4. Concurrent Transactions

**Rule**: Use database transactions to ensure atomicity.

**Implementation**:

```typescript
await prisma.$transaction(async (tx) => {
  // Create all ledger entries in one atomic transaction
  await tx.ledgerEntry.createMany({ data: entries });

  // Verify invariant
  const sum = entries.reduce((acc, e) => acc.add(e.amount), new Decimal(0));
  if (!sum.equals(0)) {
    throw new Error('Transaction sum must equal 0');
  }
});
```

---

## Performance Optimization

### Indexes

```prisma
@@index([walletId])        // Fast balance calculation
@@index([transactionId])   // Fast invariant checks
@@index([paymentId])       // Payment transaction lookup
@@index([orderId])         // Order transaction lookup
@@index([createdAt])       // Time-range queries
```

### Caching Strategy

```typescript
// Cache recent balance (if high read volume)
const cacheKey = `wallet:${walletId}:balance`;
const cached = await redis.get(cacheKey);

if (cached) return new Decimal(cached);

const balance = await this.calculateBalance(walletId);
await redis.setex(cacheKey, 300, balance.toString()); // Cache 5 min

return balance;
```

### Pagination

```typescript
// Always paginate transaction history
const PAGE_SIZE = 50;

const transactions = await prisma.ledgerEntry.findMany({
  where: { walletId },
  orderBy: { createdAt: 'desc' },
  take: PAGE_SIZE,
  skip: (page - 1) * PAGE_SIZE,
});
```

---

## Testing Guidelines

### Unit Tests

```typescript
describe('LedgerEntry', () => {
  it('should enforce non-zero amount', () => {
    expect(() => new LedgerEntry({ amount: 0 })).toThrow();
  });

  it('should calculate balance correctly', async () => {
    // Create entries: +100, -50, +25
    // Expected balance: 75
  });

  it('should enforce ledger invariant', async () => {
    // Create 3 entries that sum to 0.01
    // Should throw error
  });
});
```

### Integration Tests

```typescript
describe('Ledger Transactions', () => {
  it('should record payment with platform fee', async () => {
    // Create payment of ₹1000 with 2.5% fee
    // Verify 3 entries created
    // Verify sum = 0
    // Verify balances updated correctly
  });
});
```

---

## Troubleshooting

### Balance Mismatch

**Symptom**: Displayed balance doesn't match expected value

**Debug Steps**:

1. Query all ledger entries for wallet
2. Sum amounts manually
3. Compare with calculated balance
4. Check for missing or duplicate entries

### Invariant Violation

**Symptom**: Transaction sum != 0

**Debug Steps**:

1. Query all entries for `transactionId`
2. List amount values
3. Calculate sum with high precision
4. Check for rounding errors
5. Verify entry creation logic

### Performance Issues

**Symptom**: Slow balance queries

**Solutions**:

1. Verify indexes exist
2. Add caching layer
3. Partition old ledger entries
4. Use materialized views for reporting

---

**Last Updated**: January 1, 2026  
**Model Version**: Sprint 6A  
**Critical**: This is the source of truth for all financial data
