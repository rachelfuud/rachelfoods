/**
 * SPRINT 16 â€“ PHASE 2
 * Admin Alert Controller
 *
 * PURPOSE
 * -------
 * READ-ONLY API for querying admin alerts generated by the alert engine.
 *
 * RESPONSIBILITIES
 * ----------------
 * - GET /api/admin/alerts - Query alerts with filters
 * - GET /api/admin/alerts/:id - Get single alert by ID
 *
 * SECURITY
 * --------
 * - RBAC: PLATFORM_ADMIN, ADMIN only
 * - No mutation endpoints (READ-ONLY)
 * - Rate limiting via NestJS (if configured)
 *
 * GOLDEN RULES
 * ------------
 * - READ-ONLY (no mutations)
 * - No behavioral changes
 * - No database writes
 */

import {
    Controller,
    Get,
    Param,
    Query,
    UseGuards,
    HttpCode,
    HttpStatus,
    ParseIntPipe,
    DefaultValuePipe,
    BadRequestException,
} from '@nestjs/common';
import {
    ApiTags,
    ApiOperation,
    ApiResponse,
    ApiBearerAuth,
    ApiQuery,
    ApiParam,
} from '@nestjs/swagger';
import { AuthGuard } from '../../common/guards/auth.guard';
import { RoleGuard } from '../../common/guards/role.guard';
import { Roles } from '../../common/decorators/roles.decorator';
import { AdminAlertService } from './admin-alert.service';
import type {
    AlertSeverity,
    AlertCategory,
    AlertQueryResult,
} from './admin-alert.types';

/**
 * AdminAlertController
 * --------------------
 * READ-ONLY endpoints for querying admin alerts.
 *
 * All endpoints require PLATFORM_ADMIN or ADMIN role.
 */
@ApiTags('Admin - Risk Alerts')
@ApiBearerAuth()
@UseGuards(AuthGuard, RoleGuard)
@Roles('PLATFORM_ADMIN', 'ADMIN')
@Controller('api/admin/alerts')
export class AdminAlertController {
    constructor(private readonly alertService: AdminAlertService) { }

    /**
     * Query alerts with optional filters
     * GET /api/admin/alerts
     *
     * Query Parameters:
     * - severity: Filter by alert severity (INFO, WARNING, CRITICAL)
     * - category: Filter by alert category (FRAUD_RISK, COMPLIANCE, PROCESS_ANOMALY, SYSTEM_SIGNAL)
     * - withdrawalId: Filter by withdrawal ID
     * - userId: Filter by user ID
     * - startTime: Filter by start time (ISO 8601)
     * - endTime: Filter by end time (ISO 8601)
     * - limit: Pagination limit (default: 50, max: 100)
     * - offset: Pagination offset (default: 0)
     *
     * @returns Paginated alert results
     */
    @Get()
    @HttpCode(HttpStatus.OK)
    @ApiOperation({
        summary: 'Query admin alerts with filters',
        description:
            'Retrieve admin alerts from in-memory registry with optional filters. ' +
            'Supports pagination and time-range filtering. Admin-only endpoint.',
    })
    @ApiResponse({
        status: 200,
        description: 'Alerts retrieved successfully',
        schema: {
            type: 'object',
            properties: {
                alerts: {
                    type: 'array',
                    items: {
                        type: 'object',
                        properties: {
                            alertId: { type: 'string', example: 'a1b2c3d4...' },
                            createdAt: { type: 'string', example: '2026-01-05T10:30:00.000Z' },
                            severity: { type: 'string', enum: ['INFO', 'WARNING', 'CRITICAL'] },
                            category: {
                                type: 'string',
                                enum: ['FRAUD_RISK', 'COMPLIANCE', 'PROCESS_ANOMALY', 'SYSTEM_SIGNAL'],
                            },
                            title: { type: 'string', example: 'High-risk withdrawal requires review' },
                            description: { type: 'string', example: 'Withdrawal wdr_abc123 escalated...' },
                            relatedEventIds: { type: 'array', items: { type: 'string' } },
                            withdrawalId: { type: 'string', example: 'wdr_abc123' },
                            userId: { type: 'string', example: 'usr_def456' },
                            riskLevel: { type: 'string', enum: ['LOW', 'MEDIUM', 'HIGH'] },
                            sources: { type: 'array', items: { type: 'string' } },
                            sprint: { type: 'string', example: 'SPRINT_16_PHASE_2' },
                        },
                    },
                },
                total: { type: 'number', example: 150 },
                limit: { type: 'number', example: 50 },
                offset: { type: 'number', example: 0 },
            },
        },
    })
    @ApiResponse({ status: 400, description: 'Invalid query parameters' })
    @ApiResponse({ status: 403, description: 'Forbidden - Admin access required' })
    @ApiQuery({
        name: 'severity',
        required: false,
        enum: ['INFO', 'WARNING', 'CRITICAL'],
        description: 'Filter by alert severity',
    })
    @ApiQuery({
        name: 'category',
        required: false,
        enum: ['FRAUD_RISK', 'COMPLIANCE', 'PROCESS_ANOMALY', 'SYSTEM_SIGNAL'],
        description: 'Filter by alert category',
    })
    @ApiQuery({
        name: 'withdrawalId',
        required: false,
        type: String,
        description: 'Filter by withdrawal ID',
    })
    @ApiQuery({
        name: 'userId',
        required: false,
        type: String,
        description: 'Filter by user ID',
    })
    @ApiQuery({
        name: 'startTime',
        required: false,
        type: String,
        description: 'Filter by start time (ISO 8601)',
        example: '2026-01-01T00:00:00.000Z',
    })
    @ApiQuery({
        name: 'endTime',
        required: false,
        type: String,
        description: 'Filter by end time (ISO 8601)',
        example: '2026-01-05T23:59:59.999Z',
    })
    @ApiQuery({
        name: 'limit',
        required: false,
        type: Number,
        description: 'Pagination limit (default: 50, max: 100)',
        example: 50,
    })
    @ApiQuery({
        name: 'offset',
        required: false,
        type: Number,
        description: 'Pagination offset (default: 0)',
        example: 0,
    })
    async queryAlerts(
        @Query('severity') severity?: AlertSeverity,
        @Query('category') category?: AlertCategory,
        @Query('withdrawalId') withdrawalId?: string,
        @Query('userId') userId?: string,
        @Query('startTime') startTime?: string,
        @Query('endTime') endTime?: string,
        @Query('limit', new DefaultValuePipe(50), ParseIntPipe) limit?: number,
        @Query('offset', new DefaultValuePipe(0), ParseIntPipe) offset?: number,
    ): Promise<AlertQueryResult> {
        // Validate time range if provided
        if (startTime && !this.isValidISO8601(startTime)) {
            throw new BadRequestException('startTime must be valid ISO 8601 timestamp');
        }

        if (endTime && !this.isValidISO8601(endTime)) {
            throw new BadRequestException('endTime must be valid ISO 8601 timestamp');
        }

        if (startTime && endTime && startTime > endTime) {
            throw new BadRequestException('startTime must be before endTime');
        }

        // Validate limit
        if (limit && (limit < 1 || limit > 100)) {
            throw new BadRequestException('limit must be between 1 and 100');
        }

        // Validate offset
        if (offset && offset < 0) {
            throw new BadRequestException('offset must be non-negative');
        }

        return this.alertService.queryAlerts({
            severity,
            category,
            withdrawalId,
            userId,
            startTime,
            endTime,
            limit,
            offset,
        });
    }

    /**
     * Get single alert by ID
     * GET /api/admin/alerts/:id
     *
     * @param alertId - Alert identifier (SHA-256 hash)
     * @returns Single alert
     * @throws NotFoundException if alert not found
     */
    @Get(':id')
    @HttpCode(HttpStatus.OK)
    @ApiOperation({
        summary: 'Get single alert by ID',
        description:
            'Retrieve a specific admin alert by its ID (SHA-256 hash). ' +
            'Admin-only endpoint.',
    })
    @ApiParam({
        name: 'id',
        type: String,
        description: 'Alert ID (SHA-256 hash)',
        example: 'a1b2c3d4e5f6789abcdef0123456789abcdef0123456789abcdef0123456789',
    })
    @ApiResponse({
        status: 200,
        description: 'Alert retrieved successfully',
        schema: {
            type: 'object',
            properties: {
                alertId: { type: 'string' },
                createdAt: { type: 'string' },
                severity: { type: 'string', enum: ['INFO', 'WARNING', 'CRITICAL'] },
                category: {
                    type: 'string',
                    enum: ['FRAUD_RISK', 'COMPLIANCE', 'PROCESS_ANOMALY', 'SYSTEM_SIGNAL'],
                },
                title: { type: 'string' },
                description: { type: 'string' },
                relatedEventIds: { type: 'array', items: { type: 'string' } },
                withdrawalId: { type: 'string' },
                userId: { type: 'string' },
                riskLevel: { type: 'string', enum: ['LOW', 'MEDIUM', 'HIGH'] },
                sources: { type: 'array', items: { type: 'string' } },
                sprint: { type: 'string' },
            },
        },
    })
    @ApiResponse({ status: 404, description: 'Alert not found' })
    @ApiResponse({ status: 403, description: 'Forbidden - Admin access required' })
    async getAlertById(@Param('id') alertId: string) {
        return this.alertService.getAlertById(alertId);
    }

    /**
     * Validate ISO 8601 timestamp
     */
    private isValidISO8601(timestamp: string): boolean {
        const date = new Date(timestamp);
        return !isNaN(date.getTime()) && date.toISOString() === timestamp;
    }
}
